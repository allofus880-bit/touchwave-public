<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>TouchWave v1.6 — Triple Shockwave + Photon Trail Edition</title>
<style>
html,body{margin:0;overflow:hidden;background:#000;touch-action:none;}
#fileInput{position:fixed;top:20px;left:20px;z-index:10;}
#modeToggle{
  position:fixed;top:20px;right:20px;z-index:10;
  padding:6px 12px;color:#fff;
  background:rgba(255,255,255,0.15);
  border:1px solid #59f;border-radius:8px;
  font-family:Arial, sans-serif;
}
</style>
</head>

<body>
<input id="fileInput" type="file" accept="audio/*" multiple>
<div id="modeToggle">Mode: CENTRAL</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
/* ───────────────────────────────────────────────
   기본 Three.js 렌더링
─────────────────────────────────────────────── */
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,2000);
camera.position.z=3.5;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ───────────────────────────────────────────────
   은하수(Star Field)
─────────────────────────────────────────────── */
const starGeo=new THREE.BufferGeometry();
const starCount=20000;
const pos=new Float32Array(starCount*3);

for(let i=0;i<starCount;i++){
  const r=3*Math.random();
  const a=Math.random()*Math.PI*2;
  pos[i*3]=Math.cos(a)*r;
  pos[i*3+1]=(Math.random()-0.5)*2;
  pos[i*3+2]=Math.sin(a)*r;
}

starGeo.setAttribute("position",new THREE.BufferAttribute(pos,3));
const stars=new THREE.Points(
  starGeo,
  new THREE.PointsMaterial({color:0xffffff,size:0.01})
);
scene.add(stars);

/* ───────────────────────────────────────────────
   Shader Uniforms
─────────────────────────────────────────────── */
const u={
  u_time:{value:0},
  u_start:{value:-10},
  u_pos:{value:new THREE.Vector2(0.5,0.5)},
  u_resolution:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},
  u_corePower:{value:1.0}
};

/* ───────────────────────────────────────────────
   Triple Shockwave + Photon Trail Shader
─────────────────────────────────────────────── */
const shockMaterial=new THREE.ShaderMaterial({
  uniforms:u,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
  vertexShader:`void main(){gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform float u_time,u_start,u_corePower;
    uniform vec2 u_pos,u_resolution;
    void main(){
      float t=u_time-u_start;
      vec2 uv=gl_FragCoord.xy/u_resolution;
      float d=distance(uv,u_pos);

      float core = exp(-20.0*d)*(1.0 + u_corePower*0.3);

      float w1 = exp(-40.0*abs(d - t*0.20))*1.0;
      float w2 = exp(-55.0*abs(d - t*0.27))*0.8;
      float w3 = exp(-70.0*abs(d - t*0.34))*0.6;

      float shock = w1 + w2 + w3;
      float trail = exp(-18.0*d) * (1.0 / (1.0 + t*2.0));

      float glow = (core + shock*1.3 + trail*1.2)*0.6;

      gl_FragColor = vec4(glow, glow*0.9, glow*0.7, glow);
    }
  `
});

const shockPlane = new THREE.Mesh(new THREE.PlaneGeometry(2,2),shockMaterial);
scene.add(shockPlane);

/* ───────────────────────────────────────────────
   Mode Toggle (Central ↔ Touch)
─────────────────────────────────────────────── */
let mode="CENTRAL";
const modeBtn=document.getElementById("modeToggle");
modeBtn.onclick=()=>{
  mode=(mode==="CENTRAL")?"TOUCH":"CENTRAL";
  modeBtn.textContent="Mode: "+mode;
  if(mode==="CENTRAL") u.u_pos.value.set(0.5,0.5);
};

/* ───────────────────────────────────────────────
   Pointer
─────────────────────────────────────────────── */
function getPos(e){
  const r=renderer.domElement.getBoundingClientRect();
  let x=e.clientX,y=e.clientY;
  if(e.touches && e.touches.length>0){
    x=e.touches[0].clientX;
    y=e.touches[0].clientY;
  }
  return {
    x:(x-r.left)/r.width,
    y:1-(y-r.top)/r.height
  };
}

/* ───────────────────────────────────────────────
   Click → Shockwave
─────────────────────────────────────────────── */
window.addEventListener("pointerdown",(e)=>{
  const p=getPos(e);
  if(mode==="TOUCH") u.u_pos.value.set(p.x,p.y);
  u.u_start.value=u.u_time.value;

  camera.position.x += (Math.random()-0.5)*0.15;
  camera.position.y += (Math.random()-0.5)*0.15;
});

/* ───────────────────────────────────────────────
   Audio
─────────────────────────────────────────────── */
let audioCtx,analyser,data;

document.getElementById("fileInput").onchange=()=>{
  const el=document.getElementById("fileInput");
  el.style.display="none";

  audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  analyser=audioCtx.createAnalyser();
  analyser.fftSize=1024;
  data=new Uint8Array(analyser.frequencyBinCount);

  const files=el.files;
  let idx=0;

  function playNext(){
    const reader=new FileReader();
    reader.onload=async(ev)=>{
      const buf=await audioCtx.decodeAudioData(ev.target.result);
      const src=audioCtx.createBufferSource();
      src.buffer=buf;
      src.connect(analyser);
      analyser.connect(audioCtx.destination);
      src.start();
      src.onended=()=>{idx=(idx+1)%files.length; playNext();}
    };
    reader.readAsArrayBuffer(files[idx]);
  }
  playNext();
};

/* ───────────────────────────────────────────────
   Animate
─────────────────────────────────────────────── */
function animate(){
  requestAnimationFrame(animate);
  u.u_time.value += 0.016;

  if(analyser){
    analyser.getByteFrequencyData(data);

    let low=0, mid=0, high=0;
    for(let i=0;i<60;i++) low+=data[i];
    for(let i=60;i<200;i++) mid+=data[i];
    for(let i=200;i<data.length;i++) high+=data[i];

    u.u_corePower.value =
      (low*0.0004 + mid*0.00025 + high*0.00015);

    stars.rotation.y += (low+high)*0.0000004;
  }

  renderer.render(scene,camera);
}
animate();

/* ───────────────────────────────────────────────
   Resize
─────────────────────────────────────────────── */
window.onresize=()=>{
  u.u_resolution.value.set(window.innerWidth,window.innerHeight);
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
};
</script>
</body>
</html>
